import random

blank = [['0' for _ in range(7)] for _ in range(6)]             # intialize blank connect four board

def column_i(board, i):                                         # function returns column i of the board, i = 0, 1, ..., 6
    return [sublist[i] for sublist in board]


def print_board(board):                                         # print board in an easily readable format
    for i in range(len(board)):
        print(board[i])
 
def is_connect_four_col(i):                                     # output binary, is the selection i an integer and in the proper range
    if isinstance(i, int) and 0<= i <= 6:                       # not needed for automated game, but should be called for game w/ user input
        return True                                # valid column
    else:
        return False                               # invalid column
        
    

col_count = [0 for i in range(7)]                   # col_count[i] represents the number of times a player has placed a stone in column i, i = 0, 1, ..., 6








# input: board arrangement board, row i, player x marker mark
# output: only if player x win via horizontal/vert at row/col i

def horizontal_win_chk(board, i, mark):
    win = [mark, mark, mark, mark]
    for k in range(4):
        if board[i][k:k + 4] == win:
            return True, mark, 'wins'
    
def vertical_win_chk(board, i, mark):
    win = [mark, mark, mark, mark]
    col_i = column_i(board, i)
    for k in range(4):
        if col_i[k:k + 4] == win:
            return True, mark, 'wins'


# input: does player mark have horizontal/vert win in any row/col
# output: only if player x win via horizontally/vert

def hor_all_win_chk(board, mark):
    for i in range(6):
        if horizontal_win_chk(board, i, mark)[0] == True:
            return True, mark, 'wins'

def vert_all_win_chk(board, mark):
    for i in range(7):
        if vertical_win_chk(board, i, mark)[0] == True:
            return True, mark, 'wins'





def col_limit(x):
    for i in range(7):
        if x.count(i) > 6:
            return False
    return True

def turn_limit(x):
    if len(x) < 42:
        return True
    else:
        return False

def valid_position_sequence(x):
    if turn_limit(x) == True and col_limit(x) == True:
        return True
    else:
        return False
    
def next_pos_valid(x, i):
    if valid_position_sequence(x + [i]) == True:
        return True
    else:
        return False


def random_game(n):
    z = [i for i in range(7)]
    col_count = [0 for i in range(7)]
    turn_num = 0
    board = blank
    while win(board) == False and turn_num < 42:
        x = random.choice(z)
        place(board, turn_num, parity, pos_seq)
        col_count[x] = col_count[x] + 1
        for i in range(7):
            if col_count[i] == 6:
                z.pop(i)
        turn_num = turn_num + 1
            
def turn(turn_num, m, n):      
    if turn_num % 2 == 0:
        return m
    if turn_num % 2 == 1:
        return n

def random_game(board, turn_num, parity, pos_seq):
    while turn_num < 42:
        print(z)
        x = random.choice(z)
        print(x)
        pos_seq = pos_seq + [x]
        board[5 - col_count[x]][x] = turn(turn_num, 'L', 'K')
        turn_num = turn_num + 1
        col_count[x] = col_count[x] + 1
        parity = parity + 1
                
        print(col_count)
        print(turn_num)
        print_board(board)
        print(pos_seq)
        
        for i in range(len(col_count)):
            if col_count[i] > 6:
                col_count.remove(6)
                z.pop(i)
    
    return place(board, turn_num, parity, pos_seq)

col_count = [0 for i in range(7)]
z = [i for i in range(7)]
parity = 0
pos_seq = [0]
random_game(blank, 0, 0, [0])


    
