import random

blank = [['0' for _ in range(7)] for _ in range(6)]             # intialize blank connect four board

def column_i(board, i):                                         # function returns column i of the board, i = 0, 1, ..., 6
    return [sublist[i] for sublist in board]


def print_board(board):                                         # print board in an easily readable format
    for i in range(len(board)):
        print(board[i])
 
def is_connect_four_col(i):                                     # output binary, is the selection i an integer and in the proper range
    if isinstance(i, int) and 0<= i <= 6:                       # not needed for random game (hopefully)
        return True
    else:
        return False
        
    

col_count = [0 for i in range(7)]

    
# print(four_placement(blank, 1)[0])   
# input: board arrangement board, row i, player x marker mark
# output: does player x win via horizontal at row i
def horizontal_win_chk(board, i, mark):
    win = [mark, mark, mark, mark]
    for k in range(4):
        if board[i][k:k + 4] == win:
            return True, mark, 'wins'
    return "not win"
    
def vertical_win_chk(board, i, mark):
    win = [mark, mark, mark, mark]
    col_i = column_i(board, i)
    for k in range(4):
        if col_i[k:k + 4] == win:
            return True, mark, 'wins'
    return 'not win'

def hor_all_win_chk(board, mark):
    for i in range(6):
        if horizontal_win_chk(board, i, mark)[0] == True:
            return mark, 'wins'
    else:
        return 'not win'
def vert_all_win_chk(board, mark):
    for i in range(7):
        if vertical_win_chk(board, i, mark)[0] == True:
            return mark, 'wins'
    else:
        return 'not win'


def valid_position_sequence(x):
    if len(x) > 42:
        print('turn limit violation')
        return False
    for i in range(7):
        if x.count(i) > 6:
            return False
    return True
    

def next_pos(pos, i):
    if valid_position_sequence(pos + [i]) == True:
        return pos + [i]
    else:
        return valid_position_sequence(pos + [i])

def random_game(n):
    z = [i for i in range(7)]
    col_count = [0 for i in range(7)]
    turn_num = 0
    board = blank
    while win(board) == False and turn_num < 42:
        x = random.choice(z)
        place(board, turn_num, parity, pos_seq)
        col_count[x] = col_count[x] + 1
        for i in range(7):
            if col_count[i] == 6:
                z.pop(i)
        turn_num = turn_num + 1
            
def turn(turn_num, m, n):      
    if turn_num % 2 == 0:
        return m
    if turn_num % 2 == 1:
        return n

def random_game(board, turn_num, parity, pos_seq):
    while turn_num < 42:
        print(z)
        x = random.choice(z)
        print(x)
        pos_seq = pos_seq + [x]
        board[5 - col_count[x]][x] = turn(turn_num, 'L', 'K')
        turn_num = turn_num + 1
        col_count[x] = col_count[x] + 1
        parity = parity + 1
                
        print(col_count)
        print(turn_num)
        print_board(board)
        print(pos_seq)
        
        for i in range(len(col_count)):
            if col_count[i] > 6:
                col_count.remove(6)
                z.pop(i)
    
    return place(board, turn_num, parity, pos_seq)

col_count = [0 for i in range(7)]
z = [i for i in range(7)]
parity = 0
pos_seq = [0]
random_game(blank, 0, 0, [0])


    
